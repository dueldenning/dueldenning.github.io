import os
import sys
import logging
import logging.config

import flask
from flask import Flask, render_template, redirect, request, session, url_for
import flask_socketio
from flask_socketio import SocketIO
import yaml

from rooms import RoomsController
from tasks import Tasks

# init_logging
with open('logging.yaml', 'r') as file:
    logging.config.dictConfig(yaml.load(file))
    logging.getLogger().info('Set up logging')
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.secret_key = os.getenv('FLASK_SECRET_KEY', 'DEV_DO_NOT_USE_IN_PROD')
socketio = SocketIO(app, path='/io', logger=True)

open_rooms = RoomsController()
tasks = Tasks('./tasks')

# ----------------------------------------------------------
@app.route('/', methods=['GET'])
def on_get_index():
    session.permanent = True
    username = request.args.get('username')
    if username is not None:
        app.logger.debug('Setting username from args: ' + username)
        session['username'] = username

    if 'username' not in session:
        username = 'New User'
        app.logger.debug('Setting username to default: ' + username)
        session['username'] = username

    return render_template(
        "index.html", username=session['username'], rooms=open_rooms.open_room_names(), tasks=tasks.task_names())

# ----------------------------------------------------------
@app.route("/task/<string:task_name>/id/<int:room_id>", methods=["GET"])
def on_get_task(task_name, room_id):
    if 'username' not in session:
        return redirect(url_for('on_get_index'))

    if not tasks.exists(task_name):
        flask.abort(404)

    return render_template("task.html", username=session['username'])

# ----------------------------------------------------------
@app.route("/user.json", methods=['GET'])
def on_get_user_json():
    if 'username' not in session:
        flask.abort(404)

    return flask.json.jsonify({'username': session['username']})

@app.route("/user.js", methods=['GET'])
def on_get_user_js():
    if 'username' not in session:
        flask.abort(404)

    return render_template('user.js', username=session['username'])

# ----------------------------------------------------------
@socketio.on('connect')
def on_connect():
    app.logger.debug('On Connect:' + str(request))

@socketio.on('disconnect')
def on_disconnect():
    app.logger.debug('On Disconnect: ' + str(request))

    task_name = request.args['task_name']
    room_id = request.args['room_id']
    room_name = "{task_name}/{room_id}".format(task_name=task_name, room_id=room_id)
    username = session['username']

    metadata = open_rooms.get_metadata(room_name)

    state = metadata['state']
    state['chat'].append({
        'username': 'Server',
        'message': '{} has left the room.'.format(username),
        })

    open_rooms.emit_in_room(room_name, 'state change', {'new_state': state})
    open_rooms.leave_room(request.sid, room_name)

@socketio.on('join')
def on_join(message):
    app.logger.debug('On Join: ' + str(message))

    task_name = request.args['task_name']
    room_id = request.args['room_id']
    room_name = "{task_name}/{room_id}".format(task_name=task_name, room_id=room_id)
    username = session['username']

    room_metatdata = open_rooms.join_or_create(request.sid, room_name)

    if 'state' in room_metatdata:
        state = room_metatdata['state']
        assignments = state['assignments']
        if username in assignments:
            app.logger.warn('User already assigned. This should ever happen?')
        else:
            numb_briefs = len(state['task']['briefs'])
            num_current_assignments = len(assignments)
            assignments[username] = num_current_assignments % numb_briefs
    else:
        task = tasks.get(task_name)
        default_options = {option_name: option_values[0] for option_name, option_values in task['options'].items()}
        state = {
            'task': task,
            'options': default_options,
            'chat': [{
                'username': 'Server',
                'message': '{} room created.'.format(task_name),
            }],
            'assignments': {
                username: 0,
            },
        }
        room_metatdata['state'] = state
    state['chat'].append({
                'username': 'Server',
                'message': '{} has joined the room.'.format(username),
            })
    open_rooms.emit_in_room(room_name, 'state change', {'new_state': state})

@socketio.on('state change')
def on_relay_message(message):
    app.logger.debug('On State Change: ' + str(message))

    task_name = request.args['task_name']
    room_id = request.args['room_id']
    room_name = "{task_name}/{room_id}".format(task_name=task_name, room_id=room_id)
    username = session['username']

    new_state = message['new_state']
    
    open_rooms.get_metadata(room_name)['state'] = new_state
    open_rooms.emit_in_room(room_name, 'state change', {'new_state': new_state})


# ----------------------------------------------------------
if __name__ == "__main__":
    """
    This is run in prod only
    """
    port = os.getenv('PORT', default=None)
    socketio.run(app, host='0.0.0.0', port=port, debug=False, use_reloader=False, log_output=True)
